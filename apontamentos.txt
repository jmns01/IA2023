INFO:
-> Custo é a distância percorria (posteriormente multiplicada pela poluição de cada veiculo)
-> Vai haver transito e estradas cortadas
-> As edges têm estas keys: ['oneway', 'highway', 'length', 'bridge', 'maxspeed', 'name', 'tunnel', 'junction', 'width', 'access']
	oneway : ['True', 'False']; counter=19208
	highway : ['motorway_link', 'motorway', 'trunk_link', 'primary_link', 'secondary', 'residential', 'unclassified', 'primary', 'tertiary_link', 'tertiary', ['trunk_link', 'trunk'], 'trunk', ['unclassified', 'residential'], ['motorway_link', 'motorway'], ['secondary', 'trunk_link'], ['motorway', 'motorway_link'], 'secondary_link', 'living_street']; counter=4059
	bridge : ['yes', ['viaduct', 'yes'], 'viaduct']; counter=218
	tunnel : ['yes', 'building_passage']; counter=79
	junction : ['roundabout']; counter=678
	width : ['9', '7', '5', '4', '10', ['7.5', '4'], '3.9', '6']; counter=46
	access : ['yes', 'no', 'forestry', 'permit', 'permissive', 'designated', 'destination']; counter=282

DUVIDAS:
-> Como fazmos para o caso das autoestradas? O carro anda mais que 50km/h?
-> Como fazer para o user selecionar a rua de entrega, simplesmente escreve o nome (tem de ser igual ao q nos temos (solução: expressões regulares?))
-> Ruas que estão nas fronteiras das cidades

TODO:

-> Fazer função para coverter nº para estrada # FEITO
-> O nodes é um dic: {"id" : [{"y" : n, "x" : n, "street_count" : n}] (a outer list do value do dicionario é redundante) # FEITO
-> Fazer o randomize de cortada/transito # FEITO
-> Repensar os nodos # FEITO
-> Mudar de dicionario nodes para lista, para podermos usar o get_node_by_name e outros dos profs # FEITO
-> Remover create_node_dict
-> Remover create_edges_dict
-> Limpar Location.py
-> Remover FileToGraph.py?
-> Validar input user
-> O resultado dos algoritmos são listas de nodos, temos de converter para lista de strings de nomes de ruas # FEITO
-> Nodo sem nome ou é autoestrada ou rotunda
-> Adicionar K às ruas
-> Heuristica vai ser dinamicamente alterada
-> Motos e bikes não poedm andar em autoestradas
-> Alterar custo?
-> Falta passar de lista de ruas com as "keys" para apenas uma instancia delas (Rua x (1), Rua x (2)) => (Rua x)

-> Existem edges com origem e destino iguais com floats grandes
-> cruzamentos podem permitir a inversao de marcha que é proibida em certas avenidas
-> Fazer várias heuristicas e dps comparar o perfomance

RELATÓRIO:
-> Inicialmente iamos fazer com o FileToGraph.py (falar de como começou o projeto);
-> Definição das classes que eram pedidas no enunciado (Vehicles.py, worker.py,...);
-> Usamos a package OSMnx que é (OSMnx is a Python package to easily download, model, analyze, and visualize street networks and other geospatial features from OpenStreetMap);
-> Criação das classes para servir da representação do grafo (Ruas.py, Node-py, Graph.py);
-> O grafo que sai de (G = ox.graph_from_place(location, network_type="drive")) é um multi directed graph (falar da definição disto);
-> Separação do MultiDiGraph em dicionario graph, lista nodes e lista edges;
-> Fomos obrigados a fazer backtracking (pelo menos no DFS e BFS) (20/12/23)
-> Algumas ruas que obtemos da cidade em questão não tÊm nome disponivel. Como tal, vemos se é uma rotunda, se for o nome passa a ser "Rotunda", caso não tenha nome nem seja uma rotunda, indicamos qual a categoria da rua (Highway);
-> A procura DFS em grafos muito grandes, como é o caso, vai quase sempre não dar um caminho ótimo, isto porque ela devolve o primeiro caminho que encontra na procura em profundidade, esse primeiro caminho ser ótimo não se vai verificar maior parte das vezes devido as variadas soluções que existem para partir do emsmo nodo origem e chegar ao mesmo nodo destino. Assim, a procura BFS vai  ser sempre a melhor opção entre estes dois algoritmos, pois mesmo que tenha de expandir mais nodos para chegar a uma solução (quando o nodo destino se encontra num nível muito distante do nodo origem), garante-nos sempre a solução ótima (solução ótima não tendo em consideração pesos nem heuristicas)
-> A procura bidirecional trata-se de uma procura BFS do inicio para o fim e vice versa, é importante frisar as "ginasticas" feitas com a recontrução do path backward assim como conseguimos chegar a um meeting point.
